"""
References:
    https://eprint.iacr.org/2018/153.pdf
    https://eprint.iacr.org/2018/1043.pdf
"""

import numpy as np
from math import log
import random


def reverse_bits(n, no_of_bits):
    """Reverse bits of an integer with bitwise shifting

    :n: Number
    :no_of_bits: Number of bits in the binary representation of n
    """
    result = 0
    for i in range(no_of_bits):
        result <<= 1
        result |= n & 1
        n >>= 1
    return result


def bit_reverse_vec(values):
    """Reverses list by reversing the bits of the indices.

    Reverse indices of the given list.
    For example, reversing the list [0, 1, 2, 3, 4, 5, 6, 7] would become
    [0, 4, 2, 6, 1, 5, 3, 7], since 1 = 0b001 reversed is 0b100 = 4,
    3 = 0b011 reversed is 0b110 = 6.

    Args:
        values (list): List of values to be reversed. Length of list must be a power of two.

    Returns:
        The reversed list based on indices.
    """
    result = [0] * len(values)
    for i in range(len(values)):
        result[i] = values[reverse_bits(i, int(log(len(values), 2)))]
    return result


class SparseEncoder:
    """Sparse encoding for CKKS algorithm using power of two cyclotomic
    polynomials. We consider a subring Z[x^(N/n)]/(x^N+1)=Z[Y]/(Y^n+1) of the
    usual polynomial ring Z[x]/(x^N+1). Encoding and decoding is done as usual
    on the subring and then converted to the 'notation of' the full ring (i.e.
    y is mapped to x^(N/n) and vice versa). The usual decoding algorithm
    applied to encoded plaintexts just give the concatenation

    Attributes
    ----------
    :N: The power of two cyclotomic polynomial degree
    :n: A divisor of n determining the dimension of the plaintext space C^n
    :scale: The scale denoted by delta in the original paper for preserving
    significant bits
    """

    def __init__(self, N: int, n: int, scale: int):
        self.N = N
        self.n = n
        self.scale = scale
        root = np.exp((1j * np.pi) / self.n)

        # We can generate roots of unity by using powers of 5 since the order
        # of 5 in the multiplicative group of integers modulo n is 2^(n-2)
        # (giving all elements congruent to 1 mod 4). The rest are elements
        # congruent to 3 mod 4 and they give the conjugates of our roots.
        self.roots_of_unity = [
            (root) ** (5**j % (2 * self.n)) for j in range(0, self.n // 2)
        ]
        self.vandermonde = np.vander(self.roots_of_unity, self.n, increasing=True)

    @staticmethod
    def pi(vector: np.ndarray):
        """The natural isomorphism between H^k and C^(k/2)

        :vector: Vector in C^(k/2) for some k
        :returns: Vector in H^k constructed from the original vector where the
        (-i)-th coordinate is the conjugate of the (i)-th coordinate for all i
        in k/2
        """
        vector_conjugate = [np.conjugate(x) for x in vector[::-1]]
        return np.concatenate([vector, vector_conjugate])

    @staticmethod
    def coordinate_wise_random_rounding(vector: np.ndarray):
        """Standard implementation of coordinate-wise random rounding as
        described in section 2.4.2 of https://eprint.iacr.org/2013/293.pdf

        :vector: A vector in C^k for some k
        :returns: An integer coefficient vector in C^k with the expected value
        of each coordinate equal to the corresponding coordinate of the input
        vector
        """
        r = vector - np.floor(vector)
        f = np.array(
            [np.random.choice([c, c - 1], 1, p=[1 - c, c]) for c in r]
        ).reshape(-1)
        rounded_coordinates = vector - f
        rounded_coordinates = [int(coeff) for coeff in rounded_coordinates]
        return rounded_coordinates

    @staticmethod
    def fft(n, z, roots_of_unity):
        """Implementation based on https://eprint.iacr.org/2018/1043.pdf
        Algorithm 1

        :n: Twice the ring size
        :z: Complex vector of length n//2
        :roots_of_unity: 2*n roots of unity generated by some primitive 2n-th root
        """
        w = z
        w = bit_reverse_vec(w)
        log_len = int(log(len(z), 2))
        for logm in range(1, log_len + 1, 1):
            m = 1 << logm
            for i in range(0, n // 2, m):
                for j in range(0, m // 2, 1):
                    k = (5**j % (4 * m)) * ((n // 2) // m)
                    U = w[i + j]
                    V = w[i + j + m // 2]
                    V = V * roots_of_unity[k]
                    w[i + j] = U + V
                    w[i + j + m // 2] = U - V
        return w

    @staticmethod
    def fft_inv(n, z, roots_of_unity_inv):
        """Implementation based on https://eprint.iacr.org/2018/1043.pdf
        Algorithm 1

        :n: Twice the ring dimension
        :z: Complex vector
        :roots_of_unity_inv: 2*n many 2n-th roots of unity starting from the
        conjugate of a primitive 2n-th root (depending on the roots of unity
        used for the fft)
        """
        w = z
        log_len = int(log(len(z), 2))
        for logm in range(log_len, 0, -1):
            m = 1 << logm
            print("m:", m)
            for i in range(0, n // 2, m):
                print("i:", i)
                for j in range(0, m // 2, 1):
                    print("j:", j)
                    k = (5**j % (4 * m)) * (n // (2 * m))
                    print("index_even", i + j)
                    print("index_odd", i + j + m // 2)
                    U = w[i + j]
                    V = w[i + j + m // 2]
                    w[i + j] = U + V
                    w[i + j + m // 2] = (U - V) * roots_of_unity_inv[k]
        w = bit_reverse_vec(w)
        for i in range(n // 2):
            w[i] /= n // 2
        return w

    def proj(self, vector):
        """Take the orthogonal projection of a vector onto the image of the
        canonical embedding. This is the closest vector in the image to the
        original vector.

        :vector: A vector in C^(n)
        :returns: A vector in the image of the canonical embedding which is
        closest to the original vector
        """

        # Basis for the image of the canonical embedding is just the evaluation
        # of the basis of the polynomial ring at roots of unity (including the
        # conjugates). This basis is orthogonal only because N and so n is a
        # power of 2.
        basis = np.vstack(
            (self.vandermonde, np.flip(self.vandermonde.conj(), axis=0))
        ).T

        # Find the coordinates of the projection in terms of basis vectors
        coordinates = np.array(
            [np.real((np.vdot(vector, u) / np.vdot(u, u))) for u in basis]
        )

        # Round coordinates to actually fall into the image of the integer
        # polynomial ring
        rounded_coordinates = __class__.coordinate_wise_random_rounding(coordinates)

        # Calculate the projection vector using the coordinates
        return np.matmul(basis.T, rounded_coordinates)

    def encode(self, vector):
        """Find the polynomial representation (in the ring Z[x^(N/n)]/(x^N+1))
        of a vector in C^(n/2).

        :vector: A vector in C^(n/2)
        :returns: Polynomial representation of vector in Z[x^(N/n)]/(x^N+1)"""

        # Convert possible list to np.array
        vector = np.array(vector)

        # View as an element of H^n instead of C^(n/2) using the natural
        # isomorphism pi
        expansion = __class__.pi(vector)

        # Scale up for better precision
        scaled_expansion = self.scale * expansion

        # Project to orthogonal basis of im(embedding) and snip the conjugate
        # part
        projection = self.proj(scaled_expansion)[: self.n // 2]

        # Precompute 2nd column of the big special fourier matrix with conjugates
        roots_of_unity_inv = [
            np.exp(-2 * np.pi * 1j * k / (2 * self.n)) for k in range(0, 2 * self.n)
        ]

        # Apply FFT and fix coefficient order
        bad = __class__.fft_inv(self.n, projection, roots_of_unity_inv)
        message = [0] * ((self.n // 2) << 1)
        for i in range(self.n // 2):
            message[i] = int(bad[i].real + 0.5)
            message[i + self.n // 2] = int(bad[i].imag + 0.5)

        # View as an element of the ring Z[x^(N/n)]/(x^N+1) by shifting coefficients
        empty = (self.N) * [0]
        for i in range(self.n):
            empty[self.N // self.n * i] = message[i]

        return np.polynomial.Polynomial(empty)

    def decode(self, polynomial: np.polynomial.polynomial.Polynomial):
        """Function for the canonical embedding of Z[Y]/(Y^n+1) into C^(n/2) by
        evaluation at roots of unity

        :polynomial: a polynomial viewed as an element of Z[Y]/(Y^n+1)
        :returns: the de-scaled image of the polynomial under the canonical
        embedding
        """

        # View the polynomial in Z[x^(N/n)]/(x^N+1) as an element of Z[y]/(y^n+1)
        # and also scale down
        empty = (self.N) * [0]
        for i in range(self.n):
            empty[i] = polynomial.coef[(self.N // self.n) * i] / self.scale
        polynomial = np.polynomial.Polynomial(empty)

        # Put coefficients into a complex vector
        message = [0] * (self.n // 2)
        for i in range(self.n // 2):
            message[i] = complex(empty[i], empty[i + self.n // 2])

        # Precompute roots of unity
        roots_of_unity = [
            np.exp(2 * np.pi * 1j * k / (2 * self.n)) for k in range(0, 2 * self.n)
        ]

        # Apply FFT
        ev = __class__.fft(self.n, message, roots_of_unity)

        return ev


# np.set_printoptions(precision=2, suppress=True, linewidth=np.nan)

# s = SparseEncoder(N=4, n=4, scale=32)
# p = s.encode([34.1+43.4j,2123.2-12.3j])
# print(p)
# print(s.decode(p))
