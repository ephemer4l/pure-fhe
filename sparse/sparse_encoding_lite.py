"""
References:
    https://eprint.iacr.org/2018/153.pdf
    https://eprint.iacr.org/2018/1043.pdf
"""

import numpy as np
from math import log, pi
from cmath import exp
import random

def conjugate_vector(vector: list[complex]):
    return list(map(lambda x: x.real - x.imag, vector))

def reverse_bits(n, no_of_bits):
    """Reverse bits of an integer with bitwise shifting

    :n: Number
    :no_of_bits: Number of bits in the binary representation of n
    """
    result = 0
    for i in range(no_of_bits):
        result <<= 1
        result |= n & 1
        n >>= 1
    return result


def bit_reverse_vec(values):
    """Reverses list by reversing the bits of the indices.

    Reverse indices of the given list.
    For example, reversing the list [0, 1, 2, 3, 4, 5, 6, 7] would become
    [0, 4, 2, 6, 1, 5, 3, 7], since 1 = 0b001 reversed is 0b100 = 4,
    3 = 0b011 reversed is 0b110 = 6.

    Args:
        values (list): List of values to be reversed. Length of list must be a power of two.

    Returns:
        The reversed list based on indices.
    """
    result = [0] * len(values)
    for i in range(len(values)):
        result[i] = values[reverse_bits(i, int(log(len(values), 2)))]
    return result


class SparseEncoder:
    """Sparse encoding for CKKS algorithm using power of two cyclotomic
    polynomials. We consider a subring Z[x^(N/n)]/(x^N+1)=Z[Y]/(Y^n+1) of the
    usual polynomial ring Z[x]/(x^N+1). Encoding and decoding is done as usual
    on the subring and then converted to the 'notation of' the full ring (i.e.
    y is mapped to x^(N/n) and vice versa). The usual decoding algorithm
    applied to encoded plaintexts just give the concatenation

    Attributes
    ----------
    :N: The power of two cyclotomic polynomial degree
    :n: A divisor of n determining the dimension of the plaintext space C^n
    :scale: The scale denoted by delta in the original paper for preserving
    significant bits
    """

    def __init__(self, N: int, n: int, scale: int):
        self.N = N
        self.n = n
        self.scale = scale
        root = exp((1j * pi) / self.n)

        # We can generate roots of unity by using powers of 5 since the order
        # of 5 in the multiplicative group of integers modulo n is 2^(n-2)
        # (giving all elements congruent to 1 mod 4). The rest are elements
        # congruent to 3 mod 4 and they give the conjugates of our roots.
        self.roots_of_unity = [
            (root) ** (5**j % (2 * self.n)) for j in range(0, self.n // 2)
        ]
        # self.vandermonde = np.vander(self.roots_of_unity, self.n, increasing=True)
        self.vandermonde = [[xi**i for i in range(n)] for xi in self.roots_of_unity]
        self.vandermonde = np.array(self.vandermonde)
        print(self.vandermonde)

    @staticmethod
    def pi(vector: np.ndarray):
        """The natural isomorphism between H^k and C^(k/2)

        :vector: Vector in C^(k/2) for some k
        :returns: Vector in H^k constructed from the original vector where the
        (-i)-th coordinate is the conjugate of the (i)-th coordinate for all i
        in k/2
        """
        vector_conjugate = [np.conjugate(x) for x in vector[::-1]]
        return np.concatenate([vector, vector_conjugate])

    @staticmethod
    def random_rounding(v: float):
        r = v % 1
        print(r)
        f = np.random.choice([r, r - 1], 1, p=[1 - r, r])[0]
        rounded_coord = v - f
        return rounded_coord

    @staticmethod
    def fft(n, z, roots_of_unity):
        """Implementation based on https://eprint.iacr.org/2018/1043.pdf
        Algorithm 1

        :n: Twice the ring size
        :z: Complex vector of length n//2
        :roots_of_unity: 2*n roots of unity generated by some primitive 2n-th root
        """
        w = z
        w = bit_reverse_vec(w)
        log_len = int(log(len(z), 2))
        for logm in range(1, log_len + 1, 1):
            m = 1 << logm
            for i in range(0, n // 2, m):
                for j in range(0, m // 2, 1):
                    k = (5**j % (4 * m)) * ((n // 2) // m)
                    U = w[i + j]
                    V = w[i + j + m // 2]
                    V = V * roots_of_unity[k]
                    w[i + j] = U + V
                    w[i + j + m // 2] = U - V
        return w

    @staticmethod
    def fft_inv(n, z, roots_of_unity_inv):
        """Implementation based on https://eprint.iacr.org/2018/1043.pdf
        Algorithm 1

        :n: Twice the ring dimension
        :z: Complex vector
        :roots_of_unity_inv: 2*n many 2n-th roots of unity starting from the
        conjugate of a primitive 2n-th root (depending on the roots of unity
        used for the fft)
        """
        w = z
        log_len = int(log(len(z), 2))
        for logm in range(log_len, 0, -1):
            m = 1 << logm
            for i in range(0, n // 2, m):
                for j in range(0, m // 2, 1):
                    k = (5**j % (4 * m)) * (n // (2 * m))
                    U = w[i + j]
                    V = w[i + j + m // 2]
                    w[i + j] = U + V
                    w[i + j + m // 2] = (U - V) * roots_of_unity_inv[k]
        w = bit_reverse_vec(w)
        for i in range(n // 2):
            w[i] /= n // 2
        return w

    def encode(self, vector):
        """Find the polynomial representation (in the ring Z[x^(N/n)]/(x^N+1))
        of a vector in C^(n/2).

        :vector: A vector in C^(n/2)
        :returns: Polynomial representation of vector in Z[x^(N/n)]/(x^N+1)"""

        # Convert possible list to np.array
        vector = np.array(vector)

        # Precompute 2nd column of the big special fourier matrix with conjugates
        roots_of_unity_inv = [
            exp(-2 * pi * 1j * k / (2 * self.n)) for k in range(0, 2 * self.n)
        ]

        # Apply FFT and fix coefficient order
        bad = __class__.fft_inv(self.n, vector, roots_of_unity_inv)
        message = [0] * ((self.n // 2) << 1)
        for i in range(self.n // 2):
            message[i] = __class__.random_rounding(bad[i].real * self.scale)
            message[i + self.n // 2] = __class__.random_rounding(bad[i].imag * self.scale)

        # View as an element of the ring Z[x^(N/n)]/(x^N+1) by shifting coefficients
        empty = (self.N) * [0]
        for i in range(self.n):
            empty[self.N // self.n * i] = message[i]

        return np.polynomial.Polynomial(empty)

    def decode(self, polynomial: np.polynomial.polynomial.Polynomial):
        """Function for the canonical embedding of Z[Y]/(Y^n+1) into C^(n/2) by
        evaluation at roots of unity

        :polynomial: a polynomial viewed as an element of Z[Y]/(Y^n+1)
        :returns: the de-scaled image of the polynomial under the canonical
        embedding
        """

        # View the polynomial in Z[x^(N/n)]/(x^N+1) as an element of Z[y]/(y^n+1)
        # and also scale down
        empty = (self.N) * [0]
        for i in range(self.n):
            empty[i] = polynomial.coef[(self.N // self.n) * i] / self.scale
        polynomial = np.polynomial.Polynomial(empty)

        # Put coefficients into a complex vector
        message = [0] * (self.n // 2)
        for i in range(self.n // 2):
            message[i] = complex(empty[i], empty[i + self.n // 2])

        # Precompute roots of unity
        roots_of_unity = [
            exp(2 * pi * 1j * k / (2 * self.n)) for k in range(0, 2 * self.n)
        ]

        # Apply FFT
        ev = __class__.fft(self.n, message, roots_of_unity)

        return ev


# np.set_printoptions(precision=2, suppress=True, linewidth=np.nan)

# s = SparseEncoder(N=4, n=4, scale=32)
# p = s.encode([34.1+43.4j,2123.2-12.3j])
# p = s.encode([(0.00047111748463284087+0.2190752387526767j), (0.09327888251536716-0.1565752387526767j)])
# print(p)
# print(s.decode(p))
